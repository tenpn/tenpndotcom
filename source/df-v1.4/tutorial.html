<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>DecisionFlex: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DecisionFlex
   </div>
   <div id="projectbrief">Utilty AI for Unity</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>DecisionFlex is at its best when there are many reasons different reasons for taking an action. Let's build one to run the life of a Sims-like sim person, who has to manage attributes like thirst and hunger by choosing between multiple actions like drink and eat.</p>
<p>We could do this with a big if block - "If hunger is low, eat. Else if thirst is low, drink..." However this approach:</p>
<ul>
<li>Can easily become unwieldy as you add more attributes and actions</li>
<li>looks robotic</li>
<li>is difficult to tweak at runtime</li>
<li>can't capture subtleties. Imagine if our iPerson is only a little hungry and moderately thirsty, but is right next to a snack and far from the water fountain. What should they do? With DecisionFlex, that is resolved for you, along with all the other edge cases you didn't think of.</li>
</ul>
<blockquote class="doxtable">
<p>Open the TenPN/DecisionFlex/Demos/iPerson/DecisionFlex_iPersonTutorial scene </p>
</blockquote>
<p>When you press play, it should look like this:</p>
<div class="image">
<img src="tutorial-initial.png" alt="tutorial-initial.png"/>
<div class="caption">
Initial scene</div></div>
<p> Our sim person has four attributes: Fitness, Hunger, Thirst and Wealth. Wealth and Fitness should be high, and Hunger and Thirst should be low. The simulation already works - if you unpause the game in the top-left of the game window, you will see the attributes slowly change over time.</p>
<p>However, the sim person can't currently do anything! We need to do is integrate DecisionFlex so she has an idea of when to do what.</p>
<p>DecisionFlex uses the following definitions:</p><ul>
<li>an <b>Action</b> is discrete. DecisionFlex chooses between multiple actions to perform. There's normally one GameObject per action. In our sim person demo, the actions will be Eat, Drink, Work, Exercise and Rest.</li>
<li>a <b>Decision</b> is the act of choosing between multiple actions. It's also the hierarchy containing the action gameobjects.</li>
<li>a <b>Context</b> is the world as DecisionFlex sees it. It is a bunch of variables associated with current values. Our sim person's context will contain current Hunger, Thirst, Wealth and Fitness.</li>
<li>a <b>Consideration</b> is a single reason for choosing one action. For instance, the Work action might have a HowPoor consideration that says it's important to work when Wealth is low. There's normally one gameobject per consideration, under the respective action.</li>
</ul>
<h2>The Decision Object</h2>
<p>Let's start to set up DecisionFlex:</p>
<blockquote class="doxtable">
<p>Add a new gameobject under iPerson called Decision (the name isn't important) </p>
</blockquote>
<blockquote class="doxtable">
<p>Add a DecisionFlex (Component-&gt;TenPN-&gt;DecisionFlex-&gt;Decision Flex) script to the Decision object </p>
</blockquote>
<p>This is the script that will do all the heavy lifting. In the inspector, you'll see multiple warnings. DecisionFlex is highly flexible about how it updates and treats output, and you tell it how you want it to behave by adding some helper scripts to the decision object. There are many built-in helper scripts, but you can also write your own.</p>
<blockquote class="doxtable">
<p>Add a MakeDecisionsAtRegularIntervals script (Component-&gt;TenPN-&gt;DecisionFlex-&gt;Decision Tickers-&gt;Regular DecisionTicker") to the decision object. Set Tick Every to 1. </p>
</blockquote>
<p>This tells DecisionFlex that it should update once a second. You could also use MakeDecisionEveryFrame or TimesliceDecisionMaking. The latter is useful when budgeting for many DecisionFlex instances, as it limits X to updating a frame. You can also write your own by deriving from <a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_decision_ticker.html">TenPN.DecisionFlex.DecisionTicker</a>.</p>
<blockquote class="doxtable">
<p>Add a SelectWeightedRandom script (Component-&gt;TenPN-&gt;DecisionFlex-&gt;Selectors-&gt;Select Weighted Random ActionSelector) to the decision object </p>
</blockquote>
<p>This tells DecisionFlex that you want the sim person to make mistakes sometimes. It might be best to drink right now, but very occasionally, just to seem human, they should eat instead. DecisionFlex will make sure that the choice is never stupid, but it won't always be absolutely the best thing. We are making decisions often enough that the odd slightly-wrong choice won't matter that much.</p>
<p>You could also have used SelectHighestScore, which would pick the best thing every single time. This is best if your decisions are made very rarely, or not very tolerant of mistakes.</p>
<p>The decision object should now look like this:</p>
<div class="image">
<img src="decision-object-mid.png" alt="decision-object-mid.png"/>
<div class="caption">
Decision object in-progress</div></div>
<p> The only thing DecisionFlex is still complaining about is a ContextFactory. This is how your game tells DecisionFlex about the world. It provides one or more IContexts on request, which associates strings with values. For our sim person, that's the values for Thirst, Hunger, Wealth and Fitness. We've provided a script to do that for you this time, but your game will probably need a custom script.</p>
<blockquote class="doxtable">
<p>Add AttributeContextFactory (Component-&gt;TenPN-&gt;DecisionFlex-&gt;Demos-&gt;iPerson-&gt;Attribute ContextFactory) to the decision object. </p>
</blockquote>
<p>Every game will need a custom ContextFactory, but if you look at the script, it's exceedingly simple.</p>
<h2>Implementing Actions</h2>
<p>Now we've finished the decision object, we need to create some actions.</p>
<blockquote class="doxtable">
<p>Add gameobjects under the decision object for our actions - Drink, Eat, Exercise, Rest, Work. </p>
</blockquote>
<p>Your hierarchy should look like this: </p><pre class="fragment">iPerson
|+ Attributes
|- Decision
   |+ Drink
   |+ Eat
   |+ Exercise
   |+ Rest
   |+ Work
</pre><p>Each action object will have a script that implements <a class="el" href="interface_ten_p_n_1_1_decision_flex_1_1_i_action.html">TenPN.DecisionFlex.IAction</a> to actually do the work. If you're integrating DecisionFlex with an existing game, you might want to add the interface to your existing code. For new projects, you can also derive from <a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_action.html">TenPN.DecisionFlex.Action</a> which implements MonoBehaviour and IAction together.</p>
<p>The tutorial provides ModifyAttribute (Component-&gt;TenPN-&gt;DecisionFlex-&gt;Demos-&gt;iPerson-&gt;ModifyAttribute) for you, to change the attributes of the sim person.</p>
<blockquote class="doxtable">
<p>Add ModifyAttribute to the Drink gameobject. In the inspector for the new ModifyAttribute, click the Target dropdown, and select Thirst. Then set Boost Value to -0.8. </p>
</blockquote>
<p>This says that drinking drops our thirst by 80%.</p>
<blockquote class="doxtable">
<p>Add ModifyAttribute to Exercise; set Boost Value to 0.4 and Target to Fitness. </p>
</blockquote>
<blockquote class="doxtable">
<p>Add another ModifyAttribute to Work; set Boost to 0.04 and Target to Wealth. </p>
</blockquote>
<blockquote class="doxtable">
<p>Add <em>two</em> ModifyAttribute scripts to Eat. Set one to Boost Hunger by -0.8, and the other to Boost Fitness by -0.2. </p>
</blockquote>
<p>When DecisionFlex chooses an action, it executes all IAction scripts on that gameobject. So eating will make our sim person unfit, while at the same time reducing her hunger.</p>
<blockquote class="doxtable">
<p>Add an IdleAction script to Rest (Component-&gt;TenPN-&gt;DecisionFlex-&gt;IdleAction). </p>
</blockquote>
<p>IdleAction is a dummy script provided by DecisionFlex for actions that should have no effect on the world. This is a fallback action, for when our sim person has found nothing particularly interesting to do.</p>
<h2>Considerations</h2>
<p>The actions are complete, but DecisionFlex still doesn't know how to choose between them. You can run the scene now, and our person will behave seemingly at random. For them to act sensibly, we need to add Considerations to each action. Each consideration is a single reason for taking this action (or a reason not to take this action).</p>
<blockquote class="doxtable">
<p>Create a gameobject under Drink, and name it HowThirsty (the name isn't important) </p>
</blockquote>
<p>By convention I put my considerations under my actions like this, so I can give them nice self-documenting names. DecisionFlex would also find the considerations if you added the individual scripts to the action object.</p>
<p>Each consideration produces a value above or equal to 0 and normally below 1. The higher the value, the more we want to execute this action.</p>
<p>A <a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_consideration.html">consideration</a> script normally takes one entry from the context and processes it to produce a value. For instance, we really want to take the Drink action when Thirst is high. We added Thirst to the context in our AttributeContextFactory script.</p>
<blockquote class="doxtable">
<p>Add a FloatConsideration (Component-&gt;TenPN-&gt;DecisionFlex-&gt;Considerations-&gt;Float Consideration) to HowThirsty. </p>
</blockquote>
<blockquote class="doxtable">
<p>Set the Context Name to Thirst </p>
</blockquote>
<blockquote class="doxtable">
<p>Set the Response Curve to something similar to the following </p>
</blockquote>
<div class="image">
<img src="tutorial-thirst-response-curve.png" alt="tutorial-thirst-response-curve.png"/>
<div class="caption">
HowThirsty response curve</div></div>
<p> The x axis is the Thirst, and the y axis is the consideration value from 0 to 1. Coincidentally our Thirst axis runs from 0 to 1 too, but in the other demos, the x axis might be things like distance or ammo counts.</p>
<p>A FloatConsideration script works with a float value from the context. It then uses the animation curve you created to convert Thirst into a score. The shape of the curve tells DecisionFlex how important it is to drink given the Thirst value.</p>
<div class="image">
<img src="tutorial-thirst-response-ex.png" alt="tutorial-thirst-response-ex.png"/>
<div class="caption">
HowThirsty response curve</div></div>
<p> Eg a Thirst value of 0.5 would be scored at just over 0.1, because who really cares if you're only a bit thirsty? You'll get to it later. 0.7 would be scored at 0.6, and 0.9 would be scored at 1, because now you really need a drink.</p>
<p>We only need the one consideration for Drink, but theoretically we can have as many as we want. We'll see multiple considerations used later.</p>
<p>Let's set up Eat. We need to Eat when we're feeling particularly hungry:</p>
<blockquote class="doxtable">
<p>Add a gameobject under Eat called HowHungry </p>
</blockquote>
<blockquote class="doxtable">
<p>Add a FloatConsideration to HowHungry, setting Context Name to Hunger and a Response Curve similar to: </p>
</blockquote>
<div class="image">
<img src="tutorial-hungry-curve.png" alt="tutorial-hungry-curve.png"/>
<div class="caption">
HowHungry response curve</div></div>
<p> You see we don't really want to eat until we're quite hungry. No snacking!</p>
<p>Exercise is next:</p>
<blockquote class="doxtable">
<p>Add a gameobject under Exercise called HowUnfit </p>
</blockquote>
<blockquote class="doxtable">
<p>Add a FloatConsideration to HowUnfit, setting Context Name to Fitness and a response curve similar to: </p>
</blockquote>
<div class="image">
<img src="tutorial-fitness-curve.png" alt="tutorial-fitness-curve.png"/>
<div class="caption">
HowUnfit response curve</div></div>
<p> This is a little different to the other curves, as we care about <em>low</em> fitness, compared to high thirst or hunger. Notice how much subtlety you can get out of just curves!</p>
<p>Now, exercising is important, but you shouldn't do it if you're close to death from thirst or hunger. Because this curve reaches a max consideration value of 1, you could be quite thirsty and very unfit and look to exercise before drinking. That's dangerous! We could adjust our HowUnfit response curve so it tops out at some value, but it becomes awkward if we want to tune that in the future. Instead, we can use a built-in consideration script called ConsiderationScalar.</p>
<blockquote class="doxtable">
<p>Add another gameobject under Exercise called Priority </p>
</blockquote>
<blockquote class="doxtable">
<p>Add a ConsiderationScalar to Priority, and set the scalar to 0.5 </p>
</blockquote>
<p>A ConsiderationScalar's value is always constant, and isn't influenced by the context. When an action has more than one consideration, their values are multiplied together. Hence a value of 1 from HowUnfit is multiplied by the 0.5 Priority to be capped to 0.5. A 0.1 value from HowUnfit would result in an eventual 0.05 score for Exercise. This is a much more maintainable way to set up a priority than tweaking the HowUnfit curve by hand.</p>
<p>The Work action is set up similarly to Exercise:</p>
<blockquote class="doxtable">
<p>Add a gameobject called HowPoor to Work </p>
</blockquote>
<blockquote class="doxtable">
<p>Add a FloatConsideration to HowPoor, converting Wealth with the following curve: </p>
</blockquote>
<div class="image">
<img src="tutorial-howpoor-curve.png" alt="tutorial-howpoor-curve.png"/>
<div class="caption">
HowPoor response curve</div></div>
 <blockquote class="doxtable">
<p>Add another gameobject to Work called Priority </p>
</blockquote>
<blockquote class="doxtable">
<p>Give Priority a ConsiderationScalar of 0.75 </p>
</blockquote>
<p>In our hierarchy of iPerson needs, eating and drinking (no scalars) are more important than working (scalar of 0.75), which is more important than exercise (scalar of 0.5).</p>
<p>The Idle priority is our last resort, if everything else scores low. It doesn't need a response curve, just a low priority value to make it stand out above the noise:</p>
<blockquote class="doxtable">
<p>Add a Priority gameobject to Idle </p>
</blockquote>
<blockquote class="doxtable">
<p>Give it a ConsiderationScalar of 0.15 </p>
</blockquote>
<h2>Our First Decisions</h2>
<p>And that's it! You should be able to run the scene now and see the iPerson take sensible actions.</p>
<div class="image">
<img src="tutorial-in-progress.png" alt="tutorial-in-progress.png"/>
<div class="caption">
Sensible decisions</div></div>
<p> Let's break down what's happening:</p>
<ul>
<li>Every second, the MakeDecisionsAtRegularIntervals script calls PerformAction() on the DecisionFlex script</li>
<li>The DecisionFlex script asks the nearest <a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_context_factory.html">ContextFactory</a>, in this case AttributeContextFactory, for an <a class="el" href="interface_ten_p_n_1_1_decision_flex_1_1_i_context.html">IContext</a> object<ul>
<li>The AttributeContextFactory adds the current Thirst, Hunger, Wealth and Fitness values to the IContext and returns it to DecisionFlex</li>
</ul>
</li>
<li>DecisionFlex loops through all the Action objects:<ul>
<li>For one action, DecisionFlex loops through each Consideration, asking for a ConsiderationValue<ul>
<li>Considerations do their calculations in different ways, but most of ours are FloatConsiderations that push a single attribute value through a response curve</li>
</ul>
</li>
<li>All the consideration values are multiplied together to get a score for the action</li>
</ul>
</li>
<li>DecisionFlex passes all the scores to the nearest <a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_action_selector.html">ActionSelector</a>, in this case a SelectWeightedRandom<ul>
<li>SelectWeightedRandom uses the scores as weights and picks randomly. If one action is scored 33% and another is scored 66%, it's twice as likely to pick the 66% action.</li>
</ul>
</li>
<li>DecisionFlex calls Perform() on all the IAction scripts on the winning action object</li>
</ul>
<p>What about a concrete example? Let's say the iPerson's attributes are as follows:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Value  </th></tr>
<tr>
<td>Hunger </td><td>0.7 </td></tr>
<tr>
<td>Thirst </td><td>0.4 </td></tr>
<tr>
<td>Fitness </td><td>0.6 </td></tr>
<tr>
<td>Wealth </td><td>0.55 </td></tr>
</table>
<p>From our response curves above, that gives roughly these values for the actions:</p>
<table class="doxtable">
<tr>
<th>Action </th><th>Response Curve </th><th>Priority </th><th>Total  </th></tr>
<tr>
<td>Work </td><td>0.55 Wealth -&gt; 0.7 </td><td>0.75 </td><td><b>0.525</b> (0.6x0.75) </td></tr>
<tr>
<td>Idle </td><td>- </td><td>0.15 </td><td><b>0.15</b> </td></tr>
<tr>
<td>Eat </td><td>0.7 Hunger -&gt; 0.1 </td><td>- </td><td><b>0.1</b> </td></tr>
<tr>
<td>Exercise </td><td>0.55 Fitness -&gt; 0.1 </td><td>0.5 </td><td><b>0.05</b> (0.1x0.5) </td></tr>
<tr>
<td>Drink </td><td>0.4 Thirst -&gt; 0 </td><td>- </td><td><b>0</b> </td></tr>
</table>
<p>Because of random weighting, we can't say for sure what the final outcome will be, but Work looks like a firm favourite. Eat will start to skyrocket as hunger creeps up, because our HowHungry response curve ramps up really fast at the end. Maybe in a few turns our iPerson will eat, which will cause Fitness to drop. Then Exercising will start to rise up the charts.</p>
<h2>Runtime Debugging</h2>
<p>You can tweak all the consideration and action parameters at runtime, and watch how that changes the iPerson behaviour. But remember changes made while the game is running are not saved when you stop running!</p>
<p>At runtime, the inspector for the DecisionFlex will show the last 5 decisions made, and the full context selected with the last decision. Enabling the logging flag found there will output more information to the console. Each action's inspector will show the scores generated by the considerations associated with that action.</p>
<p>Here are some things to try:</p>
<ul>
<li>Make drinking, eating and exercising all cost wealth when executed, by adding a ModifyAttribute script to all of them. What happens?</li>
<li>How could you make the iPerson more of a health freak?</li>
<li>Add a new Snacking action that reduces hunger a little and increases fitness a little. Make an iPerson that snacks to keep hunger down, but still has complete meals occasionally.</li>
</ul>
<h2>Further Resources</h2>
<p>This system of "normalising" system variables to easily compare them is called utility theory. Here are more resources on the subject, although you can use DecisionFlex to its fullest without them:</p>
<p>Free GDC lectures from Dave Mark and Kevin Dill: <br />
<a href="http://www.gdcvault.com/play/1012410/Improving-AI-Decision-Modeling-Through">http://www.gdcvault.com/play/1012410/Improving-AI-Decision-Modeling-Through</a> <br />
<a href="http://www.gdcvault.com/play/1015683/Embracing-the-Dark-Art-of">http://www.gdcvault.com/play/1015683/Embracing-the-Dark-Art-of</a></p>
<p>Dave Mark's book on utility theory and modelling behaviours with mathematics: <br />
<a href="http://www.amazon.com/dp/1584506849">http://www.amazon.com/dp/1584506849</a></p>
<h2>The toolkit</h2>
<p>DecisionFlex comes with some built-in consideration scripts:</p>
<ul>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_binary_context_consideration.html">BinaryContextConsideration</a>: runs a value from the context through an expression, and returns one of two values depending on success. For instance, if ammo count is greater than zero, the consideration returns one, otherwise it returns zero.</li>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_consideration_scalar.html">ConsiderationScalar</a>: returns a constant score whatever context is given to it. Good for setting the priorities of an action.</li>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_float_consideration.html">FloatConsideration</a>/<a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_int_consideration.html">IntConsideration</a>: pushes a value from the context through a response curve as defined by an AnimationCurve, returning the final score.</li>
</ul>
<p>You can build your own by extending <a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_consideration.html">TenPN.DecisionFlex.Consideration</a>.</p>
<p>When returning an IContext from your ContextFactory, you can use one of the built-in context objects:</p>
<ul>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_context_dictionary.html">ContextDictionary</a> should be your first call. It's easy to make and easy to use. It doesn't allocate memory by default.</li>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_fast_context_dictionary.html">FastContextDictionary</a> does do some allocations, but is marginally faster than ContextDictionary. If profiling shows your ContextFactoryis a hotspot, switching to FastContextDictionary can be an easy win.</li>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_hierarchical_context.html">HierarchicalContext</a> pairs a self and parent IContext. If the self IContext doesn't have a particular key, it checks the parent. Of course there's nothing stopping you nesting multiple hierarchical contexts to create a whole tree. This can be useful to store common calculations between multiple objects, like a squad sharing target information.</li>
</ul>
<p>Or of course you can derive your own implementation from <a class="el" href="interface_ten_p_n_1_1_decision_flex_1_1_i_context.html">TenPN.DecisionFlex.IContext</a>.</p>
<p>To schedule the decision, use one of the <a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_decision_ticker.html">TenPN.DecisionFlex.DecisionTicker</a> scripts:</p>
<ul>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_make_decision_at_regular_intervals.html">MakeDecisionAtRegularIntervals</a></li>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_make_decision_every_frame.html">MakeDecisionEveryFrame</a></li>
<li><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_timeslice_decision_making.html">TimesliceDecisionMaking</a> takes a bucket name and a fixed update limit. Every frame, of all the DecisionFlex objects in the same bucket, only a fixed number will update. The script queues all the objects so everything gets updated eventually. This script is helpful if you will have many decision makers in the scene at once and want to budget CPU usage.</li>
</ul>
<p>You can also make your own script, and call <code>PerformAction()</code> on the DecisionFlex sript or <code>SendMessage("PerformAction")</code> to the DecisionFlex gameobject.</p>
<p><a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_context_factory.html">ContextFactory</a> implementers should return an <code>IList&lt;IContext&gt;</code> (which can be an array or a List&lt;&gt;). This is useful for when you have multiple situations you could execute actions in, and want to choose the best action/situation pair at any one time. The weapon demo scene returns one IContext per target, and chooses the best weapon/target combo.</p>
<p>However if your decision does not have multiple contexts, you can instead derive your factory from <a class="el" href="class_ten_p_n_1_1_decision_flex_1_1_single_context_factory.html">SingleContextFactory</a> and return a single IContext instead. The iPerson AttributeContextFactory does this.</p>
<h2>Demos</h2>
<p><a class="el" href="demos.html">Check out a detailed breakdown of the built-in demos here</a>. Run them from the editor and poke around their hierarchies to explore how they're put together. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
